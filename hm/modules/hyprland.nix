{ config, lib, pkgs, ... }:
with lib;
let
  cfg = config.wayland.windowManager.hyprland;
  env-import = "DISPLAY WAYLAND_DISPLAY HYPRLAND_INSTANCE_SIGNATURE XDG_CURRENT_DESKTOP";
in
{
  options.wayland.windowManager.hyprland = {
    enable = mkEnableOption "hyprland service";

    config = mkOption {
      type = types.attrs;
      default = { };
      description = ''
        Hyprland configuration variables.
        See <link xlink:href="https://wiki.hyprland.org/Configuring/Variables/">the Hyprland Wiki</link> for possible options.
      '';
    };

    extraConfig = lib.mkOption {
      type = lib.types.lines;
      default = "";
      description = ''
        Extra configuration lines to add to ~/.config/hypr/hyprland.conf.
      '';
    };
  };

  config = mkIf cfg.enable {
    home.packages = [
      pkgs.hyprland
    ];

    xdg.configFile."hypr/hyprland.conf".text =
      let
        stringify = v:
          if builtins.isBool v then (if v then "true" else "false")
          else if builtins.isFloat v then builtins.toString v
          else if builtins.isInt v then builtins.toString v
          else if builtins.isPath v then builtins.toString v
          else if builtins.isString v then v
          else throw "stringify: bad type";
        renderEntry = k: v:
          if builtins.isAttrs v then "${k} {\n${render v}\n}"
          else if builtins.isList v then concatStringsSep "\n" (map (x: "${k} = ${stringify x}") v)
          else "${k} = ${stringify v}";
        render = x: concatStringsSep "\n" (mapAttrsToList renderEntry x);
      in
      ''
        # Generated by Nix home-manager

        ${render cfg.config}

        ${cfg.extraConfig}

        exec = /bin/sh -c '${pkgs.dbus}/bin/dbus-update-activation-environment --systemd ${env-import} XDG_SESSION_TYPE=wayland; ${pkgs.systemd}/bin/systemd-notify --ready'
      '';

    xdg.configFile."hypr/hyprland.conf".onChange = ''
      (  # execute in subshell so that `shopt` won't affect other scripts
        shopt -s nullglob  # so that nothing is done if /tmp/hypr/ does not exist or is empty
        for instance in /tmp/hypr/*; do
          HYPRLAND_INSTANCE_SIGNATURE=''${instance##*/} ${pkgs.hyprland}/bin/hyprctl reload config-only \
            || true  # ignore dead instance(s)
        done
      )
    '';

    # TODO make this upstreamable
    systemd.user.services.hyprland = {
      Unit = {
        Description = "Hyprland window manager";

        Wants = [ "graphical-session-pre.target" ];
        After = [ "graphical-session-pre.target" ];
        BindsTo = [ "graphical-session.target" ];
        Before = [ "graphical-session.target" ];
        PropagateReloadFrom = [ "graphical-session.target" ];
      };

      Service = {
        Slice = "session.slice";
        Type = "notify";
        NotifyAccess = "all"; # we use systemd-notify so we need to accept startup notifications from everyone
        ExecStart = "${pkgs.hyprland}/bin/Hyprland";
        ExecReload = "${pkgs.hyprland}/bin/hyprctl reload";
        TimeoutStopSec = 10;

        Restart = "on-failure";
        RestartSec = 1;

        # TODO also need to unset in dbus?
        ExecStopPost = "${pkgs.systemd}/bin/systemctl --user unset-environment ${env-import} XDG_SESSION_TYPE";
      };
    };
  };
}
